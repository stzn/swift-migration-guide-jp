# データ競合安全

Swiftが用いる基本的な概念について学び、データ競合のない並行コードを実現する方法を知りましょう。

|原文|[https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/dataracesafety](https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/dataracesafety)|
|---|---|
|更新日|2024/8/11(翻訳を最後に更新した日付)|
|ここまで反映|https://github.com/apple/swift-migration-guide/commit/2e7fa65583c1cfc37724c98562bb256ecacb99d8|

従来、可変状態(mutable state)は、細心の注意を払い、ランタイム時の同期によって手動で保護する必要がありました。つまり、ロックやキューなどのツールを使用してデータ競合を防ぐのは、完全にプログラマー任せだということです。これは、正しく実行するだけでなく、ずっと正しく実行し続けることも非常に難しくあります。同期が*必要かどうか*を判断することさえも難しいかもしれません。最悪の状況は、安全でないコードを不正だと検知される保証がないことです。このコードは、多くの場合正しく動いているように見えますが、それはおそらく、データ競合の特徴である間違った予測不可能な挙動が表面化するのに、かなり特殊な条件が必要にだからでしょう。

より正確にいうと、データ競合は、あるスレッドがメモリにアクセスしている際に、別のスレッドが同じメモリを変更することで発生します。Swift 6言語モードでは、コンパイル時にデータ競合を防ぐことによってこれらの問題を排除します。

> 重要: 他の言語で `async`/`await` やアクターのような構造に遭遇したことがあるかもしれません。Swiftにおけるこれらの概念との類似性は表面的なものでしかない可能性があるため、特に注意してください。

## データ隔離

Swiftの並行処理システムは、コンパイラがすべての可変状態の安全性を理解し、検証できるようにしています。これは、*データ隔離*と呼ばれる仕組みで行なわれているものです。データ隔離は、可変状態への相互排他的なアクセスを保証します。これは同期メカニズムの1つの形で、概念的にはロックに似ています。しかし、ロックとは異なり、データ隔離による保護はコンパイル時に行なわれます。

Swiftプログラマーは、静的と動的という2つの方法でデータを隔離します。

*静的*という用語は、ランタイム時の状態に影響されないプログラム要素を記述するために使用されます。関数定義のようなこれらの要素は、キーワードとアノテーションで構成されます。Swiftの並行処理システムは、型システムを拡張したものです。関数と型を宣言するときは、静的に行なっています。データ隔離は、これらの静的宣言の一部である場合があります。

ただし、型システムだけでは、ランタイム時の挙動を十分に説明できない場合があります。たとえば、Swiftに公開されているObjective-Cの型です。Swiftコードの外部で行なわれたこの宣言は、安全な使用を保証するためにコンパイラに十分な情報が提供されない場合があります。このような状況に対応するために、データ隔離の要件を動的に表現できる追加機能があります。

データ隔離によって、コンパイラは、(静的であれ動的であれ)あなたの書いたSwiftコードにデータ競合がないことを保証できます。

> 注記: 動的な隔離についての詳細は、<doc:IncrementalAdoption#Dynamic-Isolation>を参照してください。

### 隔離ドメイン

データの隔離は、共有可変状態(shared mutable state)を保護するための*仕組み*です。ですが、個々の隔離について議論すると役に立つことがよくあります。これは*隔離ドメイン*と呼ばれています。特定のドメインにどれだけの状態を守る責任があるかは千差万別です。隔離ドメインは、単一の変数を保護することも、ユーザーインターフェースのようなサブシステム全体を保護することもあります。

隔離ドメインの重要な特徴は、それが提供する安全性です。可変状態は、一度に1つの隔離ドメインからのみアクセスできます。ある隔離ドメインから別の隔離ドメインに可変状態を渡すことはできますが、別のドメインからその状態に同時にアクセスすることは決してできません。コンパイラがこれが保証されているかを検証します。

たとえ自分で明示的に定義していなくても、*すべての*関数や変数の宣言には、明確に定義された静的な隔離ドメインが存在します。これらのドメインは常に次の3つのカテゴリのうちの1つに分類されます。

1. 非隔離(Non-isolated)
2. アクターに隔離されている
3. グローバルアクターに隔離されている

### 非隔離(Non-isolated)

関数や変数は、明示的な隔離ドメインの一部である必要はありません。実際、隔離されていないのがデフォルトで、*非隔離(non-isolated)*と呼ばれます。すべてのデータ隔離のルールが適用されるため、非隔離のコードは別のドメインで保護されている状態を変更できません。

```swift
func sailTheSea() {
}
```

このトップレベル関数は、隔離されていないため非隔離になります。他の非隔離の関数を呼び出したり、非隔離の変数にアクセスしたりは安全にできますが、他の隔離ドメインに存在するものには一切アクセスできません。

```swift
class Chicken {
    let name: String
    var currentHunger: HungerLevel
}
```

これは非隔離型の例です。継承は静的な隔離も引き継ぎます。しかし、スーパークラスもプロトコル準拠もないため、この単純なクラスは、デフォルトの隔離を使用しています。

データ隔離は、非隔離のものが他のドメインの可変状態にアクセスできないことを保証します。それにより、非隔離の関数や変数は、他のドメインから常に安全にアクセスできます。

### アクター

アクターは、プログラマーにそのドメイン内で動作するメソッドとともに隔離ドメインを定義する方法を提供します。アクターの格納プロパティはすべて、それらを囲むアクターインスタンスに隔離されます。

```swift
actor Island {
    var flock: [Chicken]
    var food: [Pineapple]

    func addToFlock() {
        flock.append(Chicken())
    }
}
```

ここで、すべての`Island`インスタンスは、そこに属するプロパティへのアクセスを保護するために新しいドメインを定義します。これは、メソッド`Island.addToFlock`が`self`に隔離されていると言います。メソッド本体は、その隔離ドメインを共有するすべてのデータにアクセスでき、`flock`プロパティに同期的にアクセスできます。

アクターの隔離は、選択的に無効にできます。これは、隔離されている型のなかにコードを書きたい一方で、それに伴う隔離の要件は避けたい場合に便利です。非隔離メソッドは、その隔離ドメインに保護された状態へは同期的にアクセスできません。

```swift
actor Island {
    var flock: [Chicken]
    var food: [Pineapple]

    nonisolated func canGrow() -> PlantSpecies {
        // ここではflockにもfoodにもアクセスできない。
    }
}
```

アクターの隔離ドメインは、それ自身のメソッドに限られてはいません。隔離された(isolated)パラメータを受け取る関数は、他の形式の同期を必要とせずに、アクターによって隔離された状態にアクセスできるようにします。


```swift
func addToFlock(of island: isolated Island) {
    island.flock.append(Chicken())
}
```

> 注記: アクターの概要については、The Swift Programming Language の [Actors][] セクションを参照してください。

[Actors]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency#Actors

### グローバルアクター

グローバルアクターは、通常のアクターが有するすべての特性を持ちますが、宣言をグローバルアクターの隔離ドメインへ静的に割り当てる手段も提供します。これは、アクター名と一致するアノテーションをつけることによって行なわれます。グローバルアクターは、一連の型をすべて単一の隔離ドメインに属する共有可変状態の集まりとして相互運用する必要がある場合に、特に有用です。

```swift
@MainActor
class ChickenValley {
    var flock: [Chicken]
    var food: [Pineapple]
}
```

このクラスは`MainActor`に静的に隔離されています。これにより、このクラスの可変状態へのすべてのアクセスが`MainActor`から行なわれるようになります。

`nonisolated`キーワードを使用することで、この型のアクターの隔離をオプトアウトできます。そして、他のアクターと同様に非隔離にすることで、グローバルアクターに保護された状態へのアクセスはできなくなります。

```swift
@MainActor
class ChickenValley {
    var flock: [Chicken]
    var food: [Pineapple]

    nonisolated func canGrow() -> PlantSpecies {
        // flock、food、その他のMainActorに隔離された状態にはアクセスできない
    }
}
```

### タスク

タスクは、プログラム内で並行して実行できる作業の単位です。タスクの外側でSwiftは並行コードを実行できませんが、それは常に手動で開始しなければならないということではありません。一般的に、非同期関数は、それを実行しているタスクを認識する必要はありません。実際、タスクは、多くの場合、アプリケーションフレームワーク内、あるいはプログラムのエントリーポイントといった、より高レベルで開始できます。

複数のタスクを並行して実行できますが、個々のタスクは一度に1つの関数しか実行しません。タスクは、タスク内のコードを最初から最後まで順番に実行します。

```swift
Task {
    flock.map(Chicken.produce)
}
```

タスクは、常に特定の隔離ドメインのなかで実行されます。あるアクターインスタンスやグローバルアクターに隔離されることもあれば、非隔離の場合もあります。この隔離は手動で構築できますが、コンテキストに基づいて自動的に継承される場合もあります。タスクの隔離は、他のすべてのSwiftコードと同様に、タスクがどの可変状態にアクセスできるかを決定します。

タスクは同期と非同期両方のコードを実行できます。しかし、構造やタスクの数に関係なく、同じ隔離ドメイン内の関数は、お互いに同時には実行できません。任意の隔離ドメインで同期コードを実行するタスクは、一度にたった1つだけです。

> 注記: 詳細については、The Swift Programming Languageの[Tasks][]セクションを参照してください。

[Tasks]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency#Tasks-and-Task-Groups

### 隔離の推論と継承

隔離を明示的に指定する方法はたくさんあります。しかし、宣言のコンテキストが*隔離の継承*によって暗黙的に隔離を構築することがあります。

#### クラス

サブクラスは常に親クラスと同じ隔離を持ちます。

```swift
@MainActor
class Animal {
}

class Chicken: Animal {
}
```

`Chicken`は`Animal`を継承しているため、`Animal`型の静的な隔離も暗黙的に適用されます。それだけではなく、その隔離はサブクラスから変更できません。つまり、すべての`Animal`インスタンスは`MainActor`に隔離されており、すべての`Chicken`インスタンスも同様に、`MainActor`に隔離されているということです。

型の静的な隔離は、そのプロパティとメソッドに対してもデフォルトで推論されます。

```swift
@MainActor
class Animal {
    // この型の中のすべての宣言が
    // 暗黙的に`MainActor`に隔離されている
    let name: String

    func eat(food: Pineapple) {
    }
}
```

> 注記: 詳細については、The Swift Programming Languageの[Inheritance][]セクションを参照してください。

[Inheritance]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance

#### プロトコル

プロトコルへの準拠は、暗黙的な隔離に影響を与えます。しかし、プロトコルが隔離に与える影響は、その準拠がどのように適用されるかによって異なります。

```swift
@MainActor
protocol Feedable {
    func eat(food: Pineapple)
}

// 推論された隔離は型全体に適用される
class Chicken: Feedable {
}

// 推論された隔離は、このextensionの中のみに適用される
extension Pirate: Feedable {
}
```

プロトコルの要件そのものも隔離できます。これにより、準拠する型に対する隔離がどのように推論されるかをより細かく制御できます。

```swift
protocol Feedable {
    @MainActor
    func eat(food: Pineapple)
}
```

プロトコルがどのように定義されたか、そしてそのプロトコルへの準拠がどう追加されたかに関わらず、静的な隔離の他のメカニズムを変更できません。つまり、ある型が明示的に、あるいはスーパークラスからの推論によってグローバルに隔離されている場合、プロトコル準拠を使ってもそれを変更できないということです。

> 注記: より詳細については、The Swift Programming Languageの[Protocols][]セクションを参照してください。

[Protocols]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols

#### 関数型

隔離の*推論*は、型がそのプロパティとメソッドの隔離を暗黙的に定義することを可能にします。しかし、これらはすべて*宣言*の場合です。隔離の*継承*を用いれば関数の値でも同様の効果を得られます。

デフォルトでは、クロージャはクロージャを形成したコンテキストと同じコンテキストで隔離されます。例えば、

```swift
@MainActor
class Model { ... }

@MainActor
class C {
    var models: [Model] = []

    func mapModels<Value>(
      _ keyPath: KeyPath<Model, Value>
    ) -> some Collection<Value> {
        models.lazy.map { $0[keyPath: keyPath] }
    }
}
```

上記のコードでは、`LazySequence.map`のクロージャは`@escaping (Base.Element) -> U`型です。このクロージャは、クロージャが元々形成されたメインアクター上に留まっているはずです。これにより、このクロージャは、それを囲むコンテキストから状態をキャプチャしたり、隔離されたメソッドを呼び出したりできます。

元のコンテキストと並行して実行できるクロージャは、後のセクションで説明される`@Sendable`および`sending`アノテーションを通じて明示的に示します。

並行に評価される可能性がある`async`クロージャの場合でも、クロージャは元のコンテキストの隔離をキャプチャできます。この仕組みは、`Task`のイニシャライザで使用され、デフォルトではクロージャ内に与えられた操作が元のコンテキストに隔離される一方で、明示的な隔離も指定できます。

```swift
@MainActor
func eat(food: Pineapple) {
    // この関数の宣言の静的な隔離は、ここで作成されたクロージャによってキャプチャされる
    Task {
        // クロージャの本体はMainActorの隔離を継承できる
        Chicken.prizedHen.eat(food: food)
    }

    Task { @MyGlobalActor in
        // このタスクは`MyGlobalActor`に隔離されている
    }
}
```

ここでのクロージャの型は`Task.init`によって定義されています。この宣言はどのアクターにも隔離されていませんが、新しく作られるタスクは、明示的にグローバルアクターを書かない限り、それを囲むスコープの `MainActor`による隔離を*継承*します。関数型は、隔離の動作を制御するためのさまざまなメカニズムを提供しますが、デフォルトでは他の型と同じように動作します。

> 注記: さらに詳細については、The Swift Programming Languageの[Closures][]セクションを参照してください。

## 隔離境界

隔離ドメインは可変状態を保護します。しかし、有用なプログラムはただ保護する以上のものが必要です。多くの場合、隔離ドメイン間でデータの受け渡しによって通信し、協調する必要があります。ある隔離ドメインの中へ値を移動したり、そのドメインから値を移動したりすることは、隔離境界を*越える*と呼ばれます。値が隔離境界を越えることが許されるのは、共有可変状態への同時アクセスの可能性がない場合のみです。

値は、非同期関数の呼び出しを介して、直接境界を越えることあります。*異なる*隔離ドメインで非同期関数を呼び出す場合、パラメータと戻り値はドメイン間を移動することが必要です。また、値がクロージャによってキャプチャされた場合、間接的に境界を越えることもあります。クロージャは隔離境界を越える多くの潜在的な可能性があります。クロージャは、あるドメインで作成され、別のドメインで実行される可能性があります。もっと言うと、複数の異なるドメインで実行されることさえもあり得ます。

### Sendable型

特定の型のすべての値は、スレッドセーフが型自体の特性であることによって、隔離境界を越えて安全に渡せる場合もあります。これは、`Sendable`プロトコルに準拠することで表現できます。`Sendable`に準拠しているということは、その特定の型はスレッドセーフであり、その型の値をデータ競合のリスクなしに任意の隔離ドメイン間で共有できることを意味します。

Swiftでは、値型(value type)は本質的に安全であるため、値型を使うことが推奨されています。値型を使用した場合、同じ値への参照はプログラムの別の箇所に共有できません。値型のインスタンスを関数に渡すと、関数はその値の独立したコピーを保持します。値のセマンティクスによって共有可変状態が存在しないことが保証されるため、Swiftの値型は、すべての格納プロパティも`Sendable`である場合は暗黙的に`Sendable`になります。ただし、この暗黙の準拠は、定義されたモジュールの外部には適用されません。クラスを`Sendable`にすることは、そのパブリックAPIの契約の一部であり、常に明示的に行なう必要があります。

```swift
enum Ripeness {
    case hard
    case perfect
    case mushy(daysPast: Int)
}

struct Pineapple {
    var weight: Double
    var ripeness: Ripeness
}
```

ここで、`Ripeness`と`Pineapple`の両型は、`Sendable`な値型だけで構成されているので、暗黙的に`Sendable`です。

> 注記: より詳細については、The Swift Programming Languageの[Sendable Types][]セクションを参照してください。

[Sendable Types]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency#Sendable-Types

#### フローセンシティブ(Flow-Sensitive)な隔離の解析

`Sendable`プロトコルは、型全体がスレッドセーフであることを表現するために使われます。しかし、`Sendable`ではない型の特定の*インスタンス*が安全な方法で使われていることもあります。コンパイラは、多くの場合、[リージョンベースの隔離][RBI]として知られるフローセンシティブな解析によってこの安全性を推論できます。

リージョンベースの隔離では、データ競合を起こさないとコンパイラが証明できる場合、`Sendable`でない型のインスタンスが隔離ドメインを超えることを許可します。

```swift
func populate(island: Island) async {
    let chicken = Chicken()

    await island.adopt(chicken)
}
```

上記の例で、たとえ`chicken`変数が`Sendable`ではない型を保持していたとしても、コンパイラは、`chicken`を`island`の隔離ドメインに渡しても安全であることを正しく推論できます。しかし、この`Sendable`チェックの例外的なケースは、本質的に周囲のコードに依存します。コンパイラは、`chicken`変数への安全ではないアクセスが発生した場合にエラーを発生させます。

```swift
func populate(island: Island) async {
    let chicken = Chicken()

    await island.adopt(chicken)

    // エラーになる
    chicken.eat(food: Pineapple())
}
```

リージョンベースの隔離は、コードを変更せずに機能します。一方で、この仕組みを使って、関数のパラメータと戻り値が隔離ドメインを超えられるようにしていることを明示できます。

```swift
func populate(island: Island, with chicken: sending Chicken) async {
    await island.adopt(chicken)
}
```

この`sending`の仕組みにより、コンパイラは、すべての呼び出し先において、安全ではない方法で`chicken`パラメータにアクセスされないことを100%保証できます。`sending`は、この仕組みがなければ起こっていた重大な制約を緩和します。もし`sending`がなければ、`Chicken`をまず`Sendable`に準拠させなければ、この関数は実装できませんでした。

[RBI]: https://github.com/swiftlang/swift-evolution/blob/main/proposals/0414-region-based-isolation.md

### アクターに隔離された型

アクターは値型ではありません。しかし、アクターは自身の隔離ドメインですべての状態を保護するため、境界を越えて渡しても実質的に安全です。これにより、アクター内のプロパティ自体が`Sendable`でなくても、すべてのアクターに属する型は暗黙的に`Sendable`になります。

```swift
actor Island {
    var flock: [Chicken]  // non-Sendable
    var food: [Pineapple] // Sendable
}
```

グローバルアクターに隔離された型も、同様の理由で暗黙的に`Sendable`になります。グローバルアクターそれぞれに専用の隔離ドメインはありませんが、その状態はアクターによって保護されています。

```swift
@MainActor
class ChickenValley {
    var flock: [Chicken]  // non-Sendable
    var food: [Pineapple] // Sendable
}
```

### 参照型

値型とは異なり、参照型は暗黙的に`Sendable`にはできません。明示的に`Sendable`にできますが、それにはいくつかの制約が伴います。クラスを`Sendable`にするためには、可変状態を含めてはならず、不変のプロパティも`Sendable`である必要があります。さらに、コンパイラは`final`クラスの実装のみを有効とします。

```swift
final class Chicken: Sendable {
    let name: String
}
```

OS固有の構成要素や、C/C++/Objective-Cで実装されたスレッドセーフな型を使用する場合など、コンパイラが推論できない同期プリミティブを使用して`Sendable`のスレッドセーフ要件を満たすことができます。このような型は、`@unchecked Sendable`に準拠することで、コンパイラにその型がスレッドセーフであることを約束します。コンパイラは`@unchecked Sendable`型に対してチェックを行なわないため、このオプトアウトの使用には注意が必要です。

### 中断ポイント(Suspension Points)

あるドメインの関数が別のドメインの関数を呼び出すと、タスクは隔離ドメインを切り替えることがあります。隔離境界を越える呼び出しは、呼び出し先の隔離ドメインが他のタスクの実行でビジー状態になっている可能性があるため、非同期で行なう必要があります。その場合、タスクは、呼び出し先の隔離ドメインが使用可能になるまで中断されます。重要なのは、中断ポイントがブロック*されない*ということです。現在の隔離ドメイン(およびそれが実行されているスレッド)は、他の作業をするために解放されます。Swiftの並行処理ランタイムは、コードがこの先実行されるタスクをブロックしない、つまりシステムが常に前進するようになっていると想定しています。常に前進することで、並行コードのデッドロックの一般的な原因を取り除いています。

```swift
@MainActor
func stockUp() {
    // MainActorで実行開始
    let food = Pineapple()

    // islandアクターのドメインに切り替え
    await island.store(food)
}
```

潜在的な中断ポイントは、ソースコード内で`await`キーワードを付けます。このキーワードが存在すると、呼び出しがランタイム時に中断される可能性があることを示します。ただし、`await`が付いているから中断が必ず発生するのではなく、呼び出される関数は特定の動的条件下でのみ中断される可能性があるということです。`await`が付いた呼び出しは、実際には中断されないこともあります。

### 原子性(Atomicity)

アクターはデータ競合からの安全性を保証しますが、中断ポイント間の原子性(他の処理が割り込まないこと)は保証しません。並行コードは、他のスレッドが中間状態を決して見ることができないように、一連の処理を不可分な単位としてまとめて実行する必要がよくあります。この性質を必要とするコードの単位を*クリティカルセクション(critical section)*と呼びます。

現在の隔離ドメインは、他のタスクを実行するために解放されるため、アクターで隔離されている状態は、非同期呼び出しの後に変更される可能性があります。結果として、潜在的な中断ポイントを明記することは、クリティカルセクションの終了を示す方法だと考えることができます。

```swift
func deposit(pineapples: [Pineapple], onto island: Island) async {
   var food = await island.food
   food += pineapples
   await island.store(food)
}
```

このコードでは、`island`アクターの`food`の値が、非同期呼び出しの間に変化しないと誤って想定しています。クリティカルセクションは、常に同期的に実行されるように構造化されるべきです。

> 注記: より詳細については、The Swift Programming Languageの[Defining and Calling Asynchronous Functions][]セクションを参照してください。
